<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>42 Cursus Project Inception</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>42 Cursus Project Inception</h1>
    </header>

    <nav>
        <ul>
            <li><a href="#overview">Overview</a></li>
            <li><a href="#key-components-and-their-roles">Key Components and Their Roles</a></li>
            <li><a href="#first-basics">First Basics ðŸ˜„</a></li>
            <li><a href="#docker">Docker</a></li>
            <li><a href="#docker-images">Docker Images</a></li>
            <li><a href="#docker-compose">Docker Compose</a></li>
            <li><a href="#docker-volumes">Docker Volumes</a></li>
            <li><a href="#the-network">The Network</a></li>
            <li><a href="#vms-vs-containers">VMs vs Containers</a></li>
            <li><a href="#docker-vs-lxc">Docker vs LXC</a></li>
            <li><a href="#volume-types">Volume Types</a></li>
            <li><a href="#docker-volume-drivers-and-mount-options">Docker Volume Drivers and Mount Options</a></li>
            <li><a href="#network-types">Network Types</a></li>
        </ul>
    </nav>

    <div class="container">
        <section id="overview">
            <h2>Overview</h2>
            <p>The <strong>Inception</strong> Project is a sophisticated web infrastructure, all running on the same Docker network, orchestrated using Docker and Docker Compose.</p>
            <p>NGINX manages incoming web traffic, serving static files directly and forwarding dynamic content requests to PHP-FPM, which processes PHP code from WordPress. WordPress uses Redis for caching frequently accessed data, enhancing performance by reducing database queries to MariaDB, which handles all content data storage and management. After PHP-FPM processes the request and retrieves data from Redis and MariaDB, the content is returned to NGINX for delivery to the user. Additionally, NGINX serves a Static Website for direct content delivery. Adminer provides database management for MariaDB, and Portainer oversees and monitors the Docker containers running these services. Docker volumes ensure persistent storage and efficient data management, all within a unified Docker network that facilitates seamless communication and operation across the entire system.</p>
        </section>

        <section id="key-components-and-their-roles">
            <h2>Key Components and Their Roles</h2>
            <table>
                <tr>
                    <th>Component</th>
                    <th>Role</th>
                </tr>
                <tr>
                    <td><strong>NGINX</strong></td>
                    <td>Acts as the web server and reverse proxy, handling incoming web requests efficiently. Serves static content and forwards dynamic content requests to PHP-FPM. Optimizes web performance and ensures secure connections through SSL/TLS configuration.</td>
                </tr>
                <tr>
                    <td><strong>WordPress with PHP-FPM</strong></td>
                    <td>Forms the core of the dynamic content management system (CMS). PHP-FPM processes PHP scripts, enabling WordPress to generate dynamic web pages based on user interactions, templates, and plugins. Essential for serving personalized content to users.</td>
                </tr>
                <tr>
                    <td><strong>MariaDB</strong></td>
                    <td>Serves as the relational database management system (RDBMS) for WordPress. Stores all structured data generated by WordPress, including posts, pages, comments, and settings. Ensures data persistence and integrity.</td>
                </tr>
                <tr>
                    <td><strong>Redis</strong></td>
                    <td>Acts as an in-memory data structure store, used as a database, cache, and message broker. Enhances WordPress performance by caching frequently accessed data, reducing load times, and improving the overall user experience.</td>
                </tr>
                <tr>
                    <td><strong>Static Website</strong></td>
                    <td>Represents a simple website hosted alongside the WordPress site. Demonstrates the capability to serve static content efficiently, showcasing the versatility of the NGINX server in handling different types of web content.</td>
                </tr>
                <tr>
                    <td><strong>Portainer</strong></td>
                    <td>Provides a graphical interface for managing Docker containers, images, networks, and volumes. Simplifies the administration of the Docker environment, making it easier to monitor and manage the infrastructure components.</td>
                </tr>
                <tr>
                    <td><strong>Adminer</strong></td>
                    <td>Introduces a web interface for database management, supporting operations such as viewing and editing databases, tables, and records. Complements MariaDB by providing an accessible way to interact with the database directly from a web browser.</td>
                </tr>
            </table>
        </section>

        <section id="first-basics">
            <h2>First Basics ðŸ˜„</h2>
            <h3 id="what-is-virtualization">What Is Virtualization</h3>
            <p>Virtualization involves creating virtual versions or representations of computing resourcesâ€”such as servers, storage devices, operating systems (OS), or networksâ€”that are abstracted from the underlying physical hardware. This abstraction allows for greater flexibility, scalability, and agility in managing and deploying resources. Essentially, it lets you run multiple virtual computers on a single physical machine, making it like having several computer-generated computers from one set of hardware and software.</p>

            <h3 id="what-is-a-hypervisor">What Is a Hypervisor</h3>
            <p>A hypervisor is software that enables the creation and management of virtual computing environments. It acts as a lightweight layer, either software or firmware, that sits between the physical hardware and the virtualized environments. This layer allows multiple operating systems to run concurrently on a single physical machine by abstracting and partitioning the underlying hardware resourcesâ€”such as CPUs, memory, storage, and networkingâ€”and allocating them to the virtual environments. Essentially, the hypervisor serves as the middleman, channeling resources from your physical infrastructure to various virtual instances. Hypervisors are crucial to virtualization technology, enabling efficient utilization and management of computing resources.</p>

            <h3 id="what-are-vms">What Are VMs</h3>
            <p>Virtual machines (VMs) are simulated computing environments that run on physical hardware. They enable multiple operating systems and applications to operate independently on a single physical server. Each VM functions as a separate computer, with its own operating system, resources (such as CPU, memory, and storage), and applications. VMs allow for efficient use of hardware resources, simplify system management, and provide increased flexibility in deployment and scalability.</p>

            <h3 id="what-are-containers">What Are Containers</h3>
            <p>Containers are a form of virtualization that allows you to run applications in isolated environments. They package an application and its dependencies into a single unit that can run consistently across various computing environments. This ensures that the application will work the same way regardless of where it's deployed.</p>
            <p>Containers leverage several key Linux features to provide isolation and resource management. Here are the main features:</p>
            <ul>
                <li>Namespaces: These provide process isolation by creating separate environments for containers. Each container gets its own namespace for different aspects:
                    <ul>
                        <li>PID Namespace: Isolates process IDs, so processes in one container cannot see or interact with processes in another.</li>
                        <li>Network Namespace: Provides each container with its own network stack, including IP addresses and network interfaces.</li>
                        <li>Mount Namespace: Isolates the file system, so containers have their own views of the filesystem, independent of the host.</li>
                        <li>UTS Namespace: Isolates hostname and domain name, allowing containers to have their own hostname.</li>
                        <li>IPC Namespace: Isolates inter-process communication resources, ensuring containers cannot interfere with each other's IPC mechanisms.</li>
                        <li>User Namespace: Isolates user and group IDs, enabling containers to have different user mappings from the host.</li>
                    </ul>
                </li>
                <li>Cgroups (Control Groups): These limit and isolate resource usage for containers, including CPU, memory, disk I/O, and network. This ensures that containers do not exceed their allocated resources and can help in balancing load and ensuring quality of service.</li>
                <li>Chroot: Changes the root directory for a process, isolating its file system from the rest of the system. This creates a sandbox environment, preventing the container from accessing files outside its designated directory tree.</li>
            </ul>
            <p>In summary, containers use Linux features to provide isolation, resource management, and a consistent runtime environment for applications. This enables efficient, secure, and portable application deployment across different environments.</p>
        </section>

        <section id="vms-vs-containers">
            <h2>VMs vs Containers</h2>
            <p>Both VMs and containers provide isolated environments for running applications, but they achieve this isolation in different ways.</p>
            <table>
                <tr>
                    <th>Aspect</th>
                    <th>VMs</th>
                    <th>Containers</th>
                </tr>
                <tr>
                    <td>Isolation</td>
                    <td>VMs provide hardware-level isolation by virtualizing the entire physical machine. Each VM runs its own operating system and applications.</td>
                    <td>Containers provide process-level isolation by sharing the host OS kernel. They encapsulate the application and its dependencies, ensuring consistent runtime environments.</td>
                </tr>
                <tr>
                    <td>Performance</td>
                    <td>VMs have higher overhead because they require running a separate OS for each VM. This can result in slower performance and increased resource usage.</td>
                    <td>Containers have lower overhead as they share the host OS kernel. They are lightweight and start up faster, offering better performance and resource efficiency.</td>
                </tr>
                <tr>
                    <td>Portability</td>
                    <td>VMs are less portable as they depend on the underlying hypervisor and hardware compatibility.</td>
                    <td>Containers are highly portable because they include all necessary dependencies and can run on any system with a compatible container runtime.</td>
                </tr>
                <tr>
                    <td>Resource Allocation</td>
                    <td>VMs allocate fixed amounts of resources (CPU, memory, storage) to each VM, which can lead to underutilization or overcommitment of resources.</td>
                    <td>Containers can dynamically share resources, allowing for better resource utilization and scalability.</td>
                </tr>
                <tr>
                    <td>Management</td>
                    <td>VMs require managing separate OS instances, which can be complex and resource-intensive.</td>
                    <td>Containers simplify management by running on a shared OS kernel, reducing the need for managing multiple OS instances.</td>
                </tr>
            </table>
        </section>

        <section id="docker-vs-lxc">
            <h2>Docker vs LXC</h2>
            <p>Docker and LXC (Linux Containers) are both containerization technologies, but they have different focuses and use cases.</p>
            <table>
                <tr>
                    <th>Aspect</th>
                    <th>Docker</th>
                    <th>LXC</th>
                </tr>
                <tr>
                    <td>Focus</td>
                    <td>Application-centric: Docker is designed to package and run individual applications and their dependencies in isolated containers.</td>
                    <td>System-centric: LXC is designed to run full Linux systems in containers, making it suitable for running multiple processes and services.</td>
                </tr>
                <tr>
                    <td>User Experience</td>
                    <td>Docker provides a higher-level, user-friendly interface and tooling for building, managing, and deploying containers.</td>
                    <td>LXC provides a lower-level interface, giving users more control over container configuration and management.</td>
                </tr>
                <tr>
                    <td>Image Management</td>
                    <td>Docker has a robust image management system with Docker Hub, allowing for easy distribution and versioning of container images.</td>
                    <td>LXC does not have a centralized image repository, and image management is more manual and less standardized.</td>
                </tr>
                <tr>
                    <td>Orchestration</td>
                    <td>Docker has strong support for container orchestration tools like Docker Compose, Kubernetes, and Swarm.</td>
                    <td>LXC has limited support for orchestration tools, making it less suitable for large-scale, complex deployments.</td>
                </tr>
            </table>
        </section>
        
        <section id="docker">
            <h2>Docker</h2>
            <p>Docker is a platform for developing, shipping, and running applications inside containers. It provides an efficient way to package applications with their dependencies, ensuring consistency across different environments.</p>
        </section>

        <section id="docker-images">
            <h2>Docker Images</h2>
            <p>A Docker image is a lightweight, standalone, and executable software package that includes everything needed to run a piece of software, including the code, runtime, libraries, environment variables, and configuration files. Docker images are used to create containers, which are instances of the images that run the application.</p>
            <div class="code-block">
                <pre><code># Example of a Dockerfile for a simple web application
FROM node:14

# Set the working directory
WORKDIR /app

# Copy application code
COPY . .

# Install dependencies
RUN npm install

# Expose the application port
EXPOSE 3000

# Command to run the application
CMD ["npm", "start"]
                </code></pre>
            </div>
        </section>

        <section id="docker-compose">
            <h2>Docker Compose</h2>
            <p>Docker Compose is a tool for defining and running multi-container Docker applications. With Docker Compose, you can use a YAML file to configure your application's services, networks, and volumes. Then, with a single command, you can create and start all the services defined in the configuration.</p>
            <div class="code-block">
        </section>
                    
        <section id="docker-volumes">
            <h2>Docker Volumes</h2>
            <p>Docker volumes are used to persist data generated by and used by Docker containers. They provide a way to store data outside of the container's writable layer, ensuring data is not lost when containers are stopped or removed.</p>
            <div class="code-block">
                <pre><code># Example of creating a volume
docker volume create my_volume

# Example of using a volume in a container
docker run -d -v my_volume:/data my_image
                </code></pre>
            </div>
        </section>
        <section id="volume-types">
            <h2>Volume Types</h2>
            <p>Volumes are used to persist data generated by and used by Docker containers. There are different types of volumes:</p>
            <ul>
                <li><strong>Bind Mounts:</strong> Bind mounts map a file or directory on the host machine to a file or directory in the container. They are directly dependent on the host machine's filesystem.</li>
                <li><strong>Volumes:</strong> Docker volumes are managed by Docker and are stored in a part of the host filesystem that is managed by Docker (/var/lib/docker/volumes/). They are more flexible and can be used across multiple containers.</li>
                <li><strong>tmpfs Mounts:</strong> tmpfs mounts store data in the host system's memory only, ensuring that the data is never written to the underlying storage. They are fast but ephemeral, as the data does not persist after the container stops.</li>
            </ul>
        </section>

        <section id="docker-volume-drivers-and-mount-options">
            <h2>Docker Volume Drivers and Mount Options</h2>
            <p>Docker volumes can be managed using various volume drivers and mount options to customize how they are created, accessed, and managed.</p>

            <h3>Volume Drivers</h3>
            <p>Volume drivers allow Docker to integrate with various storage solutions. Some common volume drivers include:</p>
            <ul>
                <li><strong>local:</strong> The default driver that stores volumes on the local filesystem.</li>
                <li><strong>nfs:</strong> Network File System driver for sharing volumes over a network.</li>
                <li><strong>flocker:</strong> A clustered container data volume manager.</li>
                <li><strong>azurefile:</strong> Integrates with Azure File Storage.</li>
                <li><strong>rexray/ebs:</strong> Integrates with Amazon Elastic Block Store (EBS).</li>
            </ul>

            <h3>Mount Types</h3>
            <p>Docker supports different types of mounts:</p>
            <ul>
                <li><strong>volume:</strong> A Docker-managed volume.</li>
                <li><strong>bind:</strong> A bind mount that links a path on the host to a path in the container.</li>
                <li><strong>tmpfs:</strong> A temporary filesystem mount that stores data in memory.</li>
            </ul>

            <h3>Mount Options</h3>
            <p>When defining volumes, you can specify various options to control their behavior:</p>
            <ul>
                <li><strong>readonly:</strong> Mount the volume as read-only.</li>
                <li><strong>noexec:</strong> Prevent the execution of binaries on the mounted volume.</li>
                <li><strong>nosuid:</strong> Ignore set-user-identifier or set-group-identifier bits.</li>
                <li><strong>size:</strong> Specify the size of the tmpfs mount.</li>
            </ul>
        </section>

        <section id="network-types">
            <h2>Network Types</h2>
            <p>Docker provides several network types to manage how containers communicate with each other and with external systems:</p>
            <ul>
                <li><strong>Bridge Network:</strong> The default network type for Docker containers. It allows containers to communicate with each other on the same host using a private internal network.</li>
                <li><strong>Host Network:</strong> Shares the host's network namespace with the container, providing the container with direct access to the host's network interfaces.</li>
                <li><strong>Overlay Network:</strong> Enables communication between containers running on different Docker hosts, typically used in multi-host orchestration setups like Docker Swarm or Kubernetes.</li>
                <li><strong>Macvlan Network:</strong> Assigns a MAC address to each container, making it appear as a physical device on the network. Useful for integrating containers into an existing network infrastructure.</li>
                <li><strong>None Network:</strong> Disables all networking for the container, providing a completely isolated environment.</li>
            </ul>
        </section>

    </div>
    <script src="scripts.js"></script>

</body>
</html>